<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Yamm : Yet Another Matlab MCMC code">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Yamm</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/mattpitkin/yamm">View on GitHub</a>

          <h1 id="project_title">Yamm</h1>
          <h2 id="project_tagline">Yet Another Matlab MCMC code</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/mattpitkin/yamm/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/mattpitkin/yamm/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a id="yamm" class="anchor" href="#yamm" aria-hidden="true"><span class="octicon octicon-link"></span></a>yamm</h1>

<h2>
<a id="yet-another-matlab-mcmc-code" class="anchor" href="#yet-another-matlab-mcmc-code" aria-hidden="true"><span class="octicon octicon-link"></span></a>Yet Another Matlab MCMC code</h2>

<p>Here is another Matlab (and potentially Octave compatible) code for performing Markov chain Monte Carlo parameter estimation. Other MCMC codes are available.</p>

<p>The code can use a variety of proposal functions including the "stretch" and "walk" affine invariant ensemble samplers of <a href="http://msp.org/camcos/2010/5-1/p04.xhtml">Goodman &amp; Weare</a>. It also allows a variety of prior functions (or a user defined function) for the parameters.</p>

<h2>
<a id="setup" class="anchor" href="#setup" aria-hidden="true"><span class="octicon octicon-link"></span></a>Setup</h2>

<p>You can use the code by simply adding the <code>src</code> directory to your Matlab path, e.g. in <code>bash</code> in Linux just type</p>

<pre><code>export MATLABPATH=${MATLABPATH}:path_to_repository/src
</code></pre>

<p>Alternatively run the provided <code>setup.py</code> script with</p>

<pre><code>. ./setup.sh
</code></pre>

<p>to add the paths to <code>MATLABPATH</code>, or use the <code>addpath</code> command in Matlab, or just do it through the window options.</p>

<p>If trying this with Octave just set the <code>OCTAVEPATH</code> environment variable instead, or again use the <code>addpath</code> command.</p>

<h2>
<a id="example" class="anchor" href="#example" aria-hidden="true"><span class="octicon octicon-link"></span></a>Example</h2>

<p>Here I'll give a couple of examples (well one at the moment) of setting up the likelihood and model functions and the parameters for estimation. The style of the likelihood and model functions given here are how they should be set up in general. Other examples are given in the <code>Examples</code> directory.</p>

<h3>
<a id="sinusoid-example" class="anchor" href="#sinusoid-example" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sinusoid example</h3>

<p>An example of running the code for a sinusoidal model and Gaussian likelihood is given here. First let's define the model function. Note that the model function should take three variables:</p>

<ol>
<li>a variable, in this case <code>t</code> (a vector of time stamps), that could be a single value, vector, or matrix, giving the points at which the model is evaluated;</li>
<li>a cell array (<code>parnames</code>) containing the names of any variables needed to define the model, where the names are recognised by the <code>switch</code> statement in the function;</li>
<li>a cell array (<code>parvals</code>) containing the values of each of the variables in <code>parnames</code>, which much be included in the same order. These variables can be anything - floats, integers, strings, vectors, matrices - as long as the model function knows what to do with them. However, any variables that are being estimated must just be individual real numbers.</li>
</ol>

<div class="highlight highlight-matlab"><pre><span class="pl-st">function</span> <span class="pl-v">y</span> = <span class="pl-en">sinusoid_model</span>(t, parnames, parvals)

<span class="pl-c">% check that parnames and parvals have the same length</span>
lpn = <span class="pl-k">length</span>(parnames);
lpv = <span class="pl-k">length</span>(parvals);
<span class="pl-k">if</span> lpn<span class="pl-k"> ~= </span>lpv
    <span class="pl-k">error</span>(<span class="pl-s1"><span class="pl-pds">'</span>Error: parnames and parvals are not the same length!<span class="pl-pds">'</span></span>);
<span class="pl-k">end</span>

<span class="pl-c">% extract parameter values</span>
<span class="pl-k">for</span> <span class="pl-k">i</span>=<span class="pl-c1">1</span><span class="pl-k">:</span>lpn
    <span class="pl-k">switch</span> parnames{<span class="pl-k">i</span>}
        <span class="pl-k">case</span> <span class="pl-s1"><span class="pl-pds">'</span>amp<span class="pl-pds">'</span></span> <span class="pl-c">% sinusoid amplitude</span>
            amp = parvals{<span class="pl-k">i</span>};
        <span class="pl-k">case</span> <span class="pl-s1"><span class="pl-pds">'</span>t0<span class="pl-pds">'</span></span> <span class="pl-c">% the phase epoch</span>
            t0 = parvals{<span class="pl-k">i</span>}
        <span class="pl-k">case</span> <span class="pl-s1"><span class="pl-pds">'</span>phi0<span class="pl-pds">'</span></span> <span class="pl-c">% sinusoid initial phase at t0</span>
            phi0 = parvals{<span class="pl-k">i</span>};
        <span class="pl-k">case</span> <span class="pl-s1"><span class="pl-pds">'</span>freq<span class="pl-pds">'</span></span> <span class="pl-c">% sinusoid frequency (Hz)</span>
            freq = parvals{<span class="pl-k">i</span>};
    <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-c">% generate the sinusoid at the values t</span>
y = amp<span class="pl-k"> * </span><span class="pl-k">sin</span>(<span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-k">pi</span><span class="pl-k">*</span>freq<span class="pl-k">*</span>(t<span class="pl-k">-</span>t0)<span class="pl-k"> + </span>phi0);
</pre></div>

<p>Now let's define the log likelihood function, which we'll take as a Gaussian with a stationary noise variance. Note that the log likelihood function should take in four variables:</p>

<ol>
<li>a <code>data</code> variable containing any 'data' information. In this case <code>data</code> is a cell array with the first cell containing a vector of time stamps of the data samples, the second cell containing the actual data samples, and the third cell containing the data variance, but data could contain any other information required by the likelihood function, provided the likelihood function knows what to do with it;</li>
<li>a <code>model</code> function (either a function handle or function name string) e.g. the <code>sinusoid_model</code> above;</li>
<li>a cell array <code>parnames</code> containing the model parameter names to be passed to the model (as above);</li>
<li>a cell array <code>parvals</code> containing the model parameter values to be passed to the model (as above).</li>
</ol>

<div class="highlight highlight-matlab"><pre><span class="pl-st">function</span> <span class="pl-v">logL</span> = <span class="pl-en">logL_gaussian</span>(data, model, parnames, parvals)

<span class="pl-c">% check whether model is a string or function handle</span>
<span class="pl-k">if</span> <span class="pl-k">ischar</span>(model)
    fmodel = <span class="pl-s">str2func</span>(model);
<span class="pl-k">elseif</span> <span class="pl-k">isa</span>(model, <span class="pl-s1"><span class="pl-pds">'</span>function_handle<span class="pl-pds">'</span></span>)
    fmodel = model;
<span class="pl-k">else</span>
    <span class="pl-k">error</span>(<span class="pl-s1"><span class="pl-pds">'</span>Error... Expecting a model function!<span class="pl-pds">'</span></span>);
<span class="pl-k">end</span>

<span class="pl-c">% get the data from the data cell array</span>
t = data{<span class="pl-c1">1</span>}; <span class="pl-c">% vector of time stamps at which the data is given</span>
y = data{<span class="pl-c1">2</span>}; <span class="pl-c">% vector of data (e.g. noise + signal)</span>
C = data{<span class="pl-c1">3</span>}; <span class="pl-c">% the value of the noise variance</span>

N = <span class="pl-k">length</span>(t);
invC = <span class="pl-c1">1</span><span class="pl-k">/</span>C;
lDetC = N<span class="pl-k">*</span><span class="pl-k">log</span>(C);

<span class="pl-c">% evaluate the model</span>
md = <span class="pl-k">feval</span>(fmodel, x, parnames, parvals);

<span class="pl-c">% if the model returns a NaN then set the likelihood to be zero (e.g. loglikelihood to be -inf)</span>
<span class="pl-k">if</span> <span class="pl-k">isnan</span>(md)
    logL =<span class="pl-k"> -</span><span class="pl-c1">inf</span>;
    <span class="pl-k">return</span>;
<span class="pl-k">end</span>

<span class="pl-c">% calculate the log likelihood</span>
logL =<span class="pl-k"> -</span><span class="pl-c1">0.5</span><span class="pl-k">*</span>(y<span class="pl-k"> - </span>md)<span class="pl-k">'</span><span class="pl-k"> * </span>invC<span class="pl-k"> * </span>(y<span class="pl-k"> - </span>md);
logL = logL<span class="pl-k"> - </span><span class="pl-c1">0.5</span><span class="pl-k">*</span>N<span class="pl-k">*</span><span class="pl-k">log</span>(<span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-k">pi</span>)<span class="pl-k"> - </span><span class="pl-c1">0.5</span><span class="pl-k">*</span>lDetC;

<span class="pl-k">if</span> <span class="pl-k">isnan</span>(logL)
    <span class="pl-k">error</span>(<span class="pl-s1"><span class="pl-pds">'</span>Error: log likelihood is NaN!<span class="pl-pds">'</span></span>);
<span class="pl-k">end</span>

<span class="pl-k">return</span>
</pre></div>

<p>Now let's create a script that creates some simulated data (a sinusoid added to Gaussian noise) and then uses the MCMC to extract the posteriors of two of the sinusoid parameters (the amplitude and the phase) assuming the frequency and phase epoch are known.</p>

<div class="highlight highlight-matlab"><pre><span class="pl-c">% SIMULATE DATA</span>
<span class="pl-c">% discrete times</span>
dt = <span class="pl-c1">1</span><span class="pl-k">/</span><span class="pl-c1">5</span>; <span class="pl-c">% sampling rate of signal (Hz)</span>
tlen = <span class="pl-c1">6</span>; <span class="pl-c">% length of signal (seconds)</span>
t = (<span class="pl-c1">0</span><span class="pl-k">:</span>dt<span class="pl-k">:</span>(tlen<span class="pl-k">-</span>dt))<span class="pl-k">'</span>;

<span class="pl-c">% inject a simulated sinusoidal signal model</span>
amp = <span class="pl-c1">10.0</span>; <span class="pl-c">% signal amplitude</span>
phi0 = <span class="pl-c1">2.3</span>; <span class="pl-c">% initial phase of signal (rads)</span>
f0 = <span class="pl-c1">0.788634</span>; <span class="pl-c">% signal frequency</span>
t0 = <span class="pl-c1">0</span>; <span class="pl-c">% phase epoch</span>

<span class="pl-c">% create signal injection</span>
s = sinusoid_model(t, {<span class="pl-s1"><span class="pl-pds">'</span>amp<span class="pl-pds">'</span></span>, <span class="pl-s1"><span class="pl-pds">'</span>phi0<span class="pl-pds">'</span></span>, <span class="pl-s1"><span class="pl-pds">'</span>t0<span class="pl-pds">'</span></span>, <span class="pl-s1"><span class="pl-pds">'</span>freq<span class="pl-pds">'</span></span>}, {amp, phi0, t0, freq});

<span class="pl-c">% gaussian noise model (white)</span>
sigma2 = <span class="pl-c1">16</span>; <span class="pl-c">% variance of Gaussian noise</span>
n = <span class="pl-k">sqrt</span>(sigma2)<span class="pl-k"> * </span><span class="pl-k">randn</span>(<span class="pl-k">length</span>(t), <span class="pl-c1">1</span>);

<span class="pl-c">% data (t, y, covariance matrix)</span>
y = s<span class="pl-k">+</span>n; <span class="pl-c">% signal + noise</span>
data{<span class="pl-c1">1</span>} = t;
data{<span class="pl-c1">2</span>} = y;
data{<span class="pl-c1">3</span>} = sigma2;

<span class="pl-c">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="pl-c">% define nested sampling parameters</span>
Nmcmc = <span class="pl-c1">50000</span>; <span class="pl-c">% MCMC samples</span>
Nburnin = <span class="pl-c1">50000</span>; <span class="pl-c">% burn in</span>

likelihood = @logL_gaussian;
model = @sinusoid_model;

<span class="pl-c">% setup the prior (THIS IS IMPORTANT)</span>
<span class="pl-c">% we want to estimate the 'amp' and 'phi0' parameters, so these go in a prior variable</span>
<span class="pl-c">% that defines the type of prior and range of the prior - in this case uniform priors</span>
<span class="pl-c">% over a given minimum and maximum range</span>
prior = {<span class="pl-s1"><span class="pl-pds">'</span>amp<span class="pl-pds">'</span></span>, <span class="pl-s1"><span class="pl-pds">'</span>uniform<span class="pl-pds">'</span></span>, <span class="pl-c1">0</span>, <span class="pl-c1">20</span>, <span class="pl-s1"><span class="pl-pds">'</span>fixed<span class="pl-pds">'</span></span>; ...
         <span class="pl-s1"><span class="pl-pds">'</span>phi0<span class="pl-pds">'</span></span>, <span class="pl-s1"><span class="pl-pds">'</span>uniform<span class="pl-pds">'</span></span>, <span class="pl-c1">0</span>, <span class="pl-c1">2</span><span class="pl-k">*</span><span class="pl-k">pi</span>, <span class="pl-s1"><span class="pl-pds">'</span>cyclic<span class="pl-pds">'</span></span>};

<span class="pl-c">% we need to define the other parameters needed for the model in the extraparams </span>
<span class="pl-c">% cell array variable</span>
extraparams = {<span class="pl-s1"><span class="pl-pds">'</span>freq<span class="pl-pds">'</span></span>, freq; ...
               <span class="pl-s1"><span class="pl-pds">'</span>t0<span class="pl-pds">'</span></span>, t0};

<span class="pl-c">% RUN THE MCMC (using the ensemble sampler with 10 'walkers')</span>
[post_samples, logP] = mcmc_sampler(data, likelihood, model, prior, ...
    extraparams, <span class="pl-s1"><span class="pl-pds">'</span>Nmcmc<span class="pl-pds">'</span></span>, Nmcmc, <span class="pl-s1"><span class="pl-pds">'</span>Nburnin<span class="pl-pds">'</span></span>, Nburnin, ...
    <span class="pl-s1"><span class="pl-pds">'</span>NensembleStretch<span class="pl-pds">'</span></span>, <span class="pl-c1">10</span>);
</pre></div>

<h2>
<a id="alternatives" class="anchor" href="#alternatives" aria-hidden="true"><span class="octicon octicon-link"></span></a>Alternatives</h2>

<p>For Matlab code doing a very similar job see e.g. <a href="http://www.mathworks.com/matlabcentral/fileexchange/49537-the-mcmc-hammer---affine-invariant-mcmc-sampler">The MCMC Hammer</a> by Aslak Grinsted, the <a href="http://helios.fmi.fi/%7Elainema/mcmc/">MCMC toolbox for Matlab</a> by Marko Laine, or look elsewhere on the <a href="http://www.mathworks.com/matlabcentral/fileexchange/">Matlab File Exchange</a> or <a href="https://www.google.co.uk/#q=matlab+mcmc">Google</a>! Or, alternatively if you're more into Python (as I am too!) check out <a href="http://dan.iel.fm/emcee/current/">emcee</a> (as described in Forman-Mackay et al., <a href="http://arxiv.org/abs/1202.3665">arXiv:1202.3665</a>).</p>

<p>For similar Matlab-based Bayesian parameter estimation and evidence evaluation you may also want to checkout the <a href="http://ccpforge.cse.rl.ac.uk/gf/project/multinest/frs/">Matlab implementation of MultiNest</a>.</p>

<p>© Matthew Pitkin, 2015</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Yamm maintained by <a href="https://github.com/mattpitkin">mattpitkin</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-10008049-6");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>


  </body>
</html>
